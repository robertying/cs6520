<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0044)https://pubweb.eng.utah.edu/~cs3520/hw5.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>CS 3520  Homework 5</title><link href="./CS 3520 Homework 5_files/css" rel="stylesheet"><style>td { vertical-align: baseline; } table, body, .mainfont { font-size: 18; }.schedule { font-size: 16; }body, .mainfont { font-family: 'Sorts Mill Goudy', serif; }h1, h2, h3, h4, h5, .head, .label { font-family: 'Titillium Web', sans-serif;  }.head { font-weight: bold; }a { text-decoration: none; }.highlight { font-style: italic; color: #000088 } </style></head><body style="bgcolor: white; width: 45em; margin-left: auto; margin-right: auto"><h2>CS 3520  Homework 5</h2><p class="label">Due: Wednesday, October 3rd, 2018 11:59pm</p><p>Start with <tt><a href="https://pubweb.eng.utah.edu/~cs3520/lambda+if0.rkt">lambda+if0.rkt</a></tt>, which doesn’t already include recursive binding and also doesn’t include <tt>*</tt> for multiplication.</p><h3>Part 1 — Syntactic Sugar for Recursive Bindings</h3><p>Extend the <tt>parse</tt> function so that it supports a <tt>letrec</tt> form for recursive function bindings.</p><pre>  &lt;Exp&gt; = ...
        | {letrec {[&lt;Symbol&gt; &lt;Exp&gt;]} &lt;Exp&gt;}</pre><p>You should not change the <tt>interp</tt> function at all.</p><p>The <a href="https://pubweb.eng.utah.edu/~cs3520/lecture7b.pdf">September 27 lecture slides</a> spell out how to extend the parser to make <tt>letrec</tt> work, especially at the end of part 4. You may find the following definition useful:</p><pre>  (define mk-rec-fun
    `{lambda {body-proc}
       {let {[fX {lambda {fX}
                   {let {[f {lambda {x}
                              {{fX fX} x}}]}
                     {body-proc f}}}]}
        {fX fX}}})</pre><p>The above definition makes sense only if you can keep track of different languages and how they interact. The <tt>mk-rec-fun</tt> definition above is a Plait definition. The value of <tt>mk-rec-fun</tt> is a representation of the concrete syntax of a Curly expression. If you pass <tt>mk-rec-fun</tt> to <tt>parse</tt>, you get a Plait value that is an <tt>interp</tt>retable representation of a Curly expression.</p><p>Example:</p><pre>  (test (interp (parse `{letrec {[f {lambda {n}
                                      {if0 n
                                           0
                                           {+ {f {+ n -1}} -1}}}]}
                          {f 10}})
                 mt-env)
          (numV -10))</pre><h3>Part 2 — Implementing a Two-Argument Function in Curly</h3><p>Define the Plait constant <tt>plus</tt> as a representation of the concrete syntax of a Curly expression such that </p><pre>   (interp (parse (list-&gt;s-exp (list (list-&gt;s-exp (list plus `<i>n</i>)) `<i>m</i>))) mt-env)</pre><p>produces the same value as </p><pre>   (interp (parse (list-&gt;s-exp (list `+ `<i>n</i> `<i>m</i>))) mt-env)</pre><p>for any Plait number <tt><i>n</i></tt> and <tt><i>m</i></tt>.</p><p>In other words, you add a Plait definition</p><pre>   (define plus `{lambda ....})</pre><p>to the interepreter program, replacing the <tt>....</tt> with somethig that creates the desired Curly function.</p><p>You should not change the <tt>interp</tt> or <tt>parse</tt> function for this part.</p><h3>Part 3 — Implementing a Recursive Function in the Curly</h3><p>Define the Plait constant <tt>times</tt> such that </p><pre>   (interp (parse (list-&gt;s-exp (list (list-&gt;s-exp (list times `<i>n</i>)) `<i>m</i>))) mt-env)</pre><p>produces the same value as <tt>(numV (* <i>n</i> <i>m</i>))</tt> for any non-negative Plait integers <tt><i>n</i></tt> and <tt><i>m</i></tt>.</p><p>You should not change the <tt>interp</tt> or <tt>parse</tt> function for this part.</p><hr><table width="100%"><tbody><tr><td align="right">Last update: Tuesday, October 9th, 2018<address>mflatt@cs.utah.edu</address></td></tr></tbody></table>
</body></html>