<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0044)https://pubweb.eng.utah.edu/~cs3520/hw1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>CS 3520  Homework 1</title><link href="./CS 3520 Homework 1_files/css" rel="stylesheet"><style>td { vertical-align: baseline; } table, body, .mainfont { font-size: 18; }.schedule { font-size: 16; }body, .mainfont { font-family: 'Sorts Mill Goudy', serif; }h1, h2, h3, h4, h5, .head, .label { font-family: 'Titillium Web', sans-serif;  }.head { font-weight: bold; }a { text-decoration: none; }.highlight { font-style: italic; color: #000088 } </style></head><body style="bgcolor: white; width: 45em; margin-left: auto; margin-right: auto"><h2>CS 3520  Homework 1</h2><p class="label">Due: Wednesday, August 29th, 2018 11:59pm</p><p>The following <tt>Tree</tt> datatype implements a binary tree with a number in each node and leaf:</p><pre>  (define-type Tree
    (leaf [val : Number])
    (node [val : Number]
          [left : Tree]
          [right : Tree]))
</pre><h3>Part 1 — Sum</h3><p>Implement a <tt>sum</tt> function that takes a tree and returns the sum of the numbers in the tree.</p><p>Example: <tt>(sum (node 5 (leaf 6) (leaf 7)))</tt> should produce <tt>18</tt>.</p><h3>Part 2 — Negate</h3><p>Implement the function <tt>negate</tt>, which takes a tree and returns a tree that has the same shape, but with all the numbers negated.</p><p>Example: <tt>(negate (node 5 (leaf 6) (leaf 7)))</tt> should produce <tt>(node -5 (leaf -6) (leaf -7))</tt>.</p><h3>Part 3 — Contains?</h3><p>Implement the function <tt>contains?</tt>, which takes a tree and a number and returns <tt>#t</tt> if the number is in the tree, <tt>#f</tt> otherwise.</p><p>Example: <tt>(contains? (node 5 (leaf 6) (leaf 7)) 6)</tt> should produce <tt>#t</tt>.</p><p>The second argument to the <tt>contains?</tt> function is “along for the ride.”</p><h3>Part 4 — Big Leaves?</h3><p>Implement the function <tt>big-leaves?</tt>, which takes a tree and returns <tt>#t</tt> if every leaf is bigger than the sum of numbers in the path of nodes from the root that reaches the leaf.</p><p>Examples: <tt>(big-leaves? (node 5 (leaf 6) (leaf 7)))</tt> should produce <tt>#t</tt>, while <tt>(big-leaves? (node 5 (node 2 (leaf 8) (leaf 6)) (leaf 7)))</tt> should produce <tt>#f</tt> (since 6 is smaller than 5 plus 2).</p><p>The <tt>big-leaves?</tt> function should be a thin wrapper on another function, perhaps <tt>bigger-leaves?</tt>, that accumulates a sum of node values.</p><h3>Part 5 — Optional challenge: Sorted?</h3><p>Implement the function <tt>sorted?</tt>, which takes a tree and determines whether it is sorted in the sense that the numbers increase (or stay the same) in a inorder travsersal of the tree.</p><p>Your function should run in time proportional to the size of the tree, which rules out making a list of the tree numbers using <tt>append</tt> on recursive calls. One possible solution accumulates a compound value, and another possible solution accumulates information on the way down the tree and returns more than just success or failure.</p><hr><table width="100%"><tbody><tr><td align="right">Last update: Friday, September 14th, 2018<address>mflatt@cs.utah.edu</address></td></tr></tbody></table>
</body></html>